QUESTION 1
"""

def rsa_manual_encrypt(plaintext, e, n):
    print(f"Encrypting plaintext: '{plaintext}'")
    print(f"Using public key (e={e}, n={n})\n")

    # Step 1: Define the character-to-number mapping
    # A=00, B=01, ..., Z=25, SPACE=26
    char_map = {chr(65 + i): f"{i:02d}" for i in range(26)}
    char_map[' '] = "26"

    # Step 2: Convert the entire plaintext message into a string of numbers
    numeric_string = ""
    for char in plaintext.upper():
        if char in char_map:
            numeric_string += char_map[char]
        else:
            print(f"Warning: Character '{char}' not in map, skipping.")

    print(f"Plaintext converted to numeric string: {numeric_string}")

    # Step 3: Group the numeric string into blocks of 2 digits.
    # Since n=100, each block P must be < 100. A block size of 2 digits ensures this.
    blocks = [int(numeric_string[i:i+2]) for i in range(0, len(numeric_string), 2)]
    print(f"Numeric string grouped into blocks (P): {blocks}")

    # Step 4: Encrypt each block using the formula C = P^e mod n
    ciphertext_blocks = []
    for p_block in blocks:
        c_block = pow(p_block, e, n)
        ciphertext_blocks.append(c_block)

    print(f"Encrypted ciphertext blocks (C): {ciphertext_blocks}\n")
    return ciphertext_blocks


message = "HOW ARE YOU"
public_exponent_e = 13
modulus_n = 100
encrypted_result = rsa_manual_encrypt(message, public_exponent_e, modulus_n)
print(f"The final encrypted message is the sequence of blocks: {encrypted_result}")


"""QUESTION 2"""

import math

def find_modular_inverse(a, m):
    if math.gcd(a, m) != 1:
        return None
    r1, r2 = a, m
    s1, s2 = 1, 0
    m0 = m
    while r2 > 0:
        q = r1 // r2
        r = r1 - q * r2
        r1, r2 = r2, r
        s = s1 - q * s2
        s1, s2 = s2, s
    return s1 % m0

def factor_n(n):
    # Start checking for factors from 2 up to the square root of n.
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            p = i
            q = n // i
            return p, q
    return None, None # Should not happen for valid RSA n

def find_private_key_d(e, n):
    print(f"Attempting to find private key 'd' for public key (e={e}, n={n})\n")

    # Step 1: Factor n to find p and q
    p, q = factor_n(n)
    if not p:
        print("Failed to factor n.")
        return None
    print(f"Step 1: Factored n into p and q.")
    print(f"   p = {p}")
    print(f"   q = {q}")
    print(f"   Verification: {p} * {q} = {p * q} (matches n={n})")

    # Step 2: Calculate phi(n) = (p-1) * (q-1)
    phi_n = (p - 1) * (q - 1)
    print(f"\nStep 2: Calculated phi(n).")
    print(f"   phi(n) = ({p}-1) * ({q}-1) = {phi_n}")

    # Step 3: Find the modular inverse of e mod phi(n) to get d
    d = find_modular_inverse(e, phi_n)
    if not d:
        print(f"Failed to find modular inverse for e={e} and phi(n)={phi_n}.")
        return None
    print(f"\nStep 3: Calculated d as the modular inverse of e mod phi(n).")
    print(f"   d * {e} mod {phi_n} = 1")
    print(f"   Private exponent d = {d}")

    return d
public_exponent_e = 17
modulus_n = 187
private_key_d = find_private_key_d(public_exponent_e, modulus_n)
if private_key_d:
   print(f"The private key 'd' is: {private_key_d}")
else:
   print("Could not determine the private key.")

"""QUESTION 3"""

def rsa_cyclic_attack(c, e, n):
    print(f"--- Simulating Cyclic Attack ---")
    print(f"Intercepted Ciphertext (C): {c}")
    print(f"Public Key (e={e}, n={n})\n")

    # The list to store the sequence of generated ciphertexts
    cycle_history = [c]

    # Start the process with the initial ciphertext
    current_c = c
    iteration = 1

    while True:
        print(f"Iteration {iteration}:")
        # Formula: C_next = (C_current)^e mod n
        next_c = pow(current_c, e, n)

        print(f"   Encrypting {current_c} -> ({current_c}^{e}) mod {n} = {next_c}")

        # Check if we have completed the cycle
        if next_c == c:
            print(f"\nCycle detected! The sequence has returned to the original ciphertext {c}.")
            # The plaintext is the value right before the cycle completed.
            plaintext = current_c
            print(f"The plaintext P is the previous value in the cycle: {plaintext}")
            break

        # If no cycle, update the current value and continue
        current_c = next_c
        cycle_history.append(current_c)
        iteration += 1

        # Safety break to prevent infinite loops in case of an issue
        if iteration > 100:
            print("Attack stopped after 100 iterations. Cycle not found.")
            plaintext = None
            break

    print(f"\nFull Cycle History: {cycle_history}")
    return plaintext


intercepted_ciphertext = 22
public_exponent_e = 3
modulus_n = 35

# Run the cyclic attack simulation
discovered_plaintext = rsa_cyclic_attack(intercepted_ciphertext, public_exponent_e, modulus_n)

if discovered_plaintext is not None:
    print(f"The plaintext discovered via the cyclic attack is: {discovered_plaintext}")
else:
    print("Could not discover the plaintext.")

"""QUESTION 4"""

import math
def find_modular_inverse(a, m):
    if math.gcd(a, m) != 1:
        return None
    r1, r2 = a, m
    s1, s2 = 1, 0
    m0 = m
    while r2 > 0:
        q = r1 // r2
        r, s = (r1 - q * r2), (s1 - q * s2)
        r1, r2 = r2, r
        s1, s2 = s2, s
    return s1 % m0

def factor_n(n):
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return i, n // i
    return None, None

def find_private_key_d(e, n):
    p, q = factor_n(n)
    if not p: return None
    phi_n = (p - 1) * (q - 1)
    d = find_modular_inverse(e, phi_n)
    return d


def rsa_chosen_ciphertext_attack(c, p_original, e, n):
    print(f"Original Plaintext (P) for verification: {p_original}")
    print(f"Intercepted Ciphertext (C): {c}")
    print(f"Public Key (e={e}, n={n})\n")

    # --- Step 1: Eve's Actions ---
    print("--- Step 1: Eve prepares her attack ---")
    # a. Eve chooses a random integer X such that gcd(X, n) = 1.
    X = 2
    print(f"a. Eve chooses a random integer X = {X}")

    # b. Eve calculates the disguised ciphertext Y = C * X^e mod n
    X_pow_e = pow(X, e, n)
    Y = (c * X_pow_e) % n
    print(f"b. Eve calculates Y = (C * X^e) mod n")
    print(f"   Y = ({c} * {X}^{e}) mod {n} = {Y}")

    # --- Step 2: Bob's (Unwitting) Action ---
    print("\n--- Step 2: Eve tricks Bob into decrypting Y ---")
    # c. To simulate Bob, we first need his private key 'd'.
    d = find_private_key_d(e, n)
    if not d:
        print("Could not find Bob's private key 'd'. Attack fails.")
        return None
    print(f"c. Bob has private key d = {d}.")

    # Bob decrypts Y to get Z = Y^d mod n.
    Z = pow(Y, d, n)
    print(f"   Bob decrypts Y and returns Z = Y^d mod n = {Z}")

    # --- Step 3: Eve's Final Calculation ---
    print("\n--- Step 3: Eve finds the original plaintext P ---")
    # d. Eve calculates the inverse of her chosen X.
    X_inv = find_modular_inverse(X, n)
    if not X_inv:
        print(f"Could not find inverse of X={X}. Attack fails.")
        return None
    print(f"d. Eve calculates the inverse of her X: {X}^-1 mod {n} = {X_inv}")

    # Eve finds the original plaintext P = Z * X^-1 mod n
    P_discovered = (Z * X_inv) % n
    print(f"   Eve discovers P = (Z * X^-1) mod n = ({Z} * {X_inv}) mod {n} = {P_discovered}")

    return P_discovered


intercepted_ciphertext = 57
original_plaintext = 8
public_exponent_e = 7
modulus_n = 143

discovered_plaintext = rsa_chosen_ciphertext_attack(intercepted_ciphertext, original_plaintext, public_exponent_e, modulus_n)
if discovered_plaintext is not None:
    print(f"The plaintext discovered via the chosen-ciphertext attack is: {discovered_plaintext}")
    if discovered_plaintext == original_plaintext:
            print("Verification Successful: Discovered plaintext matches the original.")
    else:
            print("Verification Failed: Discovered plaintext does not match.")
else:
        print("The attack could not be completed.")